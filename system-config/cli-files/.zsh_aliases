# cdchawthorne

alias ls='ls --color=auto --group-directories-first'

alias grep='grep --colour=auto'
alias fgrep='fgrep --colour=auto'
alias egrep='egrep --colour=auto'

alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias lr='ls -lrt'
alias liesl='ls'
alias s='ls'
alias sl='ls'

alias freedom!=free

function cd {
    builtin cd $@ && ls
}
alias scd='cd'
alias d='cd'
alias cd..='cd ..'
alias c='cd'
alias dc='cd'
alias dcd='cd'

alias xp='chmod +x'
alias ff='find . -name'
alias fr='find . -regex'
alias rlwrap='rlwrap -s 1000000'
alias math='rlwrap math'
alias racket='rlwrap racket'
alias mount='mount -o gid=users,fmask=113,dmask=002'
alias sudo='sudo '
alias xargs='xargs '
alias startx='builtin cd; command startx &> "${HOME}/.xsession-errors"'
alias p='cd ${HOME}/repos/personal'
alias k='pwsafe -p'

alias tim='vim -t'
alias vv='vim -c ''e $MYVIMRC'''
alias vz='vim ~/.zsh_aliases'
alias sz='source ~/.zsh_aliases'
function fim {
    vim -c "cs f f $1"
}

alias rh='rehash'
alias u='sudo zsh -c ''aura -Syu; aura -Akua; ntpd -q; hwclock -w'''

function timestamp {
    date +'%Y-%m-%d__%H-%M-%S'
}

function pa {
    if [[ $# -eq 0 ]]; then
        num=1
    else
        num=$1
    fi

    dest=.
    for i in $(seq ${num}); do
        dest=${dest}/..
    done
    cd ${dest}
}

function find-grep {
    find . -regex $1 | xargs egrep --colour=auto $2 |
            sed -re 's_^([^:]*):.*$_\1_g' | uniq
}

function to {
    cd "$(dirname $1)"
}

function pdf {
    for pdfFile in $@; do
        zathura --fork "$(realpath ${pdfFile})" &> /dev/null
    done
}

function backup {
    backup_dir=${HOME}/.backup
    targets=(${HOME}/documents ${HOME}/media/pictures ${HOME}/utilities
             ${HOME}/.cdchawthorne_jade_db ${HOME}/.gnupg ${HOME}/.pere
             ${HOME}/.ssh ${HOME}/.config ${HOME}/scratch)
    backup="${backup_dir}/$(hostname)_$(timestamp).tar.gz"
    encrypted_backup=${backup}.gpg
    remote_machine=cdchawth@linux.student.cs.uwaterloo.ca
    remote_backup_dir='~/utilities/remote_backups'
    pwsafe_db=${HOME}/.pwsafe.dat

    echo "Compressing backup..."
    tar -czf ${backup} ${targets}
    echo "Encrypting backup..."
    xcowsay "Encrypting backup..."
    gpg -c --force-mdc --cipher-algo AES256 ${backup}
    echo "Transfer backup?"
    xcowsay "Ready to transfer backup"
    read -q transfer
    if [[ ${transfer} == y ]]; then
        echo "Transferring..."
        ssh ${remote_machine} rm "${remote_backup_dir}/$(hostname)_*.tar.gz.gpg"

        scp ${encrypted_backup} ${pwsafe_db} ${remote_machine}:${remote_backup_dir}
    fi
    rm -f ${backup} ${encrypted_backup}
}

function x {
    if ! pgrep X &> /dev/null; then
        builtin cd
        command startx &> "${HOME}/.xsession-errors"
    fi
}

function xvim {
    if [[ -n ${DISPLAY} || ${zsh_parent_process} == sshd ]]; then
        echo -ne '\e[1 q'
    else
        echo -ne '\e[?6c'
    fi
    vim $@

    optionRegex='^-.*$'
    for arg in $@; do
        if [[ ! ${arg} =~ ${optionRegex} && -e ${arg} && ! -x ${arg} ]]; then
            chmod +x ${arg}
        fi
    done
}

function zvim {
    if [[ -n ${DISPLAY} || ${zsh_parent_process} == "sshd" ]]; then
        echo -ne '\e[1 q'
    else
        echo -ne '\e[?6c'
    fi
    vim -u <(cat << EOF
exe "source " fnameescape("${HOME}/.vimrc")
autocmd BufNewFile *
    \ setfiletype zsh |
    \ 0put = '#!/usr/bin/env zsh' |
    \ 1put = '' |
    \ normal G
EOF) $@

    optionRegex='^-.*$'
    for arg in $@; do
        if [[ ! ${arg} =~ ${optionRegex} && -e ${arg} && ! -x ${arg} ]]; then
            chmod +x ${arg}
        fi
    done
}

function python {
    (
        export INPUTRC=${HOME}/.pyinputrc
        command python $@
    )
}

alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

function perms {
    target_dir=/music/cdchawth
    find ${target_dir} -type f | read-lines-array files
    for file in ${files}; do
        chmod 640 ${file}
        setfacl -m u:mpd:r ${file}
    done
    find ${target_dir} -type d | read-lines-array dirs
    for dir in ${dirs}; do
        chmod 750 ${dir}
        setfacl -m u:mpd:rx ${dir}
    done
    setfacl -b ${target_dir}/README
    chmod a+r ${target_dir}/README
}

function get-album {
    function echo_sql {
        echo "SELECT base_location.path || '/' || item_extra.location || " \
             "X'0A' || item_extra.title"
        echo "FROM album, item_extra, item, base_location"
        echo "WHERE item_extra.item_pid = item.item_pid AND"
        echo "      album.album_pid = item.album_pid AND"
        echo "      album.album = '$1' AND"
        echo "      base_location.base_location_id = item.base_location_id;"
    }

    if [[ $# -ne 2 ]]; then
        echo "USAGE: get-album IPHONE_MOUNT ALBUM_NAME" 1>&2
        return 1
    fi

    target_dir="${HOME}/media/music/albums/purchases/$(echo $2 | sed -r 's/ /_/g')"
    mkdir -p ${target_dir}

    echo_sql $2 | sqlite3 $1/iTunes_Control/iTunes/MediaLibrary.sqlitedb |
        read-lines-array songs

    i=1
    while [[ $i -lt ${#songs} ]]; do
        location=${songs[i]}
        title_base="$(echo ${songs[$((i+1))]} | sed -re 's/ /_/g' -e 's/\//_slash_/g')"
        title_extension="$(echo ${location} | sed -re 's/^.*\.([^.]*)/\1/g')"
        if [[ ${title_extension} == ${location} ]]; then
            echo "Unable to extract extension: ${title_base} at ${location}" 1>&2
            cp $1/${location} ${target_dir}/${title_base}.UNKNOWN_EXTENSION
        else
            cp $1/${location} ${target_dir}/${title_base}.${title_extension}
        fi
        i=$((i+2))
    done
}

function usb-backup {
    if [[ $# -ne 1 ]]; then
        echo "USAGE: usb-backup target" 1>&2
        return 1
    fi

    targets=(${HOME}/documents ${HOME}/media ${HOME}/utilities
             ${HOME}/.gnupg ${HOME}/.pere ${HOME}/.ssh ${HOME}/.config
             ${HOME}/scratch ${HOME}/.pwsafe.dat)

    if ! rsync -avz --delete ${targets} $1; then
        echo "rsync failed; trying as sudo" 1>&2
        sudo rsync -avz --delete ${targets} $1
    fi
}
