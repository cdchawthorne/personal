#!/bin/bash

# TODO: Fix the exit status on this
#       Make it so one non-existent file doesn't foobar the entire backup
#       Make it so the following won't screw up:
#       backup foo/file1 bar/file1
#       (The two files will likely be copied at the same time.)
#       (Maybe use realpaths; I don't think a nanosecond timestamp is necessary.)
#       (In the case of "backup foo foo", it would be sensible to overwrite.)
        

usage() {
    echo "Usage: $(basename $0) FILE" 1>&2
    exit 1
}

if [ $# -eq 0 ]; then
    usage
fi

if [[ ! -v BACKUP_DIR ]]; then
    BACKUP_DIR="${HOME}/utilities/backups"
fi

if [[ ! -e "${BACKUP_DIR}" ]]; then
    mkdir -p "${BACKUP_DIR}"
fi

for file in "$@"; do
    if [[ ! -e ${file} ]]; then
        echo "Error: nonexistent file ${file}" 1>&2
        exit 1
    fi

    file_basename=$(basename "${file}")
    undot_basename=${file_basename/#./dot_}
    backup_filename="${BACKUP_DIR}/${undot_basename}-$(timestamp).bak"
    cp "${file}" "${backup_filename}"
done

exit 0
